using UnityEngine;
using System.Collections.Generic;

namespace WallChess
{
    public class PlayerController : MonoBehaviour
    {
        private WallChessGameManager gameManager;
        private GridSystem gridSystem;
        private Camera mainCamera;
        
        [Header("Debug")]
        public bool enableDebugLogs = true;

        public void Initialize(WallChessGameManager gm)
        {
            gameManager = gm;
            gridSystem = gm.GetGridSystem();
            mainCamera = Camera.main;
            
            // Add drag controllers to both avatars
            SetupAvatarDragControllers();
            
            if (enableDebugLogs) Debug.Log("PlayerController initialized with drag system");
        }
        
        void SetupAvatarDragControllers()
        {
            // Add drag controller to player avatar
            GameObject playerAvatar = gameManager.GetPlayerAvatar();
            if (playerAvatar != null)
            {
                AvatarDragController playerDrag = playerAvatar.GetComponent<AvatarDragController>();
                if (playerDrag == null)
                {
                    playerDrag = playerAvatar.AddComponent<AvatarDragController>();
                }
                playerDrag.Initialize(this, true); // true = is player
                Debug.Log("Player avatar drag controller setup complete");
            }

            // Add drag controller to opponent avatar  
            GameObject opponentAvatar = gameManager.GetOpponentAvatar();
            if (opponentAvatar != null)
            {
                AvatarDragController opponentDrag = opponentAvatar.GetComponent<AvatarDragController>();
                if (opponentDrag == null)
                {
                    opponentDrag = opponentAvatar.AddComponent<AvatarDragController>();
                }
                opponentDrag.Initialize(this, false); // false = is opponent
                Debug.Log("Opponent avatar drag controller setup complete");
            }
        }

        public bool CanMoveAvatar(bool isPlayer)
        {
            if (isPlayer)
                return gameManager.currentState == GameState.PlayerTurn;
            else
                return gameManager.currentState == GameState.OpponentTurn;
        }

        public Vector2Int GetAvatarPosition(bool isPlayer)
        {
            return isPlayer ? gameManager.playerPosition : gameManager.opponentPosition;
        }

        public void MoveAvatar(bool isPlayer, Vector2Int newPosition)
        {
            if (isPlayer)
            {
                gameManager.MovePlayer(newPosition);
            }
            else
            {
                gameManager.MoveOpponent(newPosition);
            }
            
            gameManager.EndTurn();
        }

        /// <summary>
        /// Get valid moves considering wall blocking
        /// </summary>
        public List<Vector2Int> GetValidMoves(Vector2Int currentPos)
        {
            List<Vector2Int> validMoves = new List<Vector2Int>();
            
            Vector2Int[] directions = {
                Vector2Int.up, Vector2Int.down,
                Vector2Int.left, Vector2Int.right
            };

            foreach (Vector2Int direction in directions)
            {
                Vector2Int newPos = currentPos + direction;
                
                // Check grid bounds
                if (!IsValidGridPosition(newPos)) continue;
                
                // Check tile occupancy - can't move to occupied tiles
                Vector2Int playerPos = gameManager.playerPosition;
                Vector2Int opponentPos = gameManager.opponentPosition;
                if (newPos == playerPos || newPos == opponentPos) continue;
                
                // Check wall blocking using ImprovedCollisionChecker
                Vector3 fromWorld = GridToWorldPosition(currentPos);
                Vector3 toWorld = GridToWorldPosition(newPos);
                if (ImprovedCollisionChecker.IsBlocked(fromWorld, toWorld)) continue;
                
                validMoves.Add(newPos);
            }

            return validMoves;
        }

        public bool IsValidMove(Vector2Int from, Vector2Int to)
        {
            // Check if it's a single step move
            Vector2Int diff = to - from;
            if (Mathf.Abs(diff.x) + Mathf.Abs(diff.y) != 1) return false;
            
            // Check grid bounds
            if (!IsValidGridPosition(to)) return false;
            
            // Check tile occupancy - can't move to tiles occupied by other avatar
            Vector2Int playerPos = gameManager.playerPosition;
            Vector2Int opponentPos = gameManager.opponentPosition;
            if (to == playerPos || to == opponentPos) return false;
            
            // Check wall blocking using ImprovedCollisionChecker
            Vector3 fromWorld = GridToWorldPosition(from);
            Vector3 toWorld = GridToWorldPosition(to);
            return !ImprovedCollisionChecker.IsBlocked(fromWorld, toWorld);
        }

        bool IsValidGridPosition(Vector2Int pos)
        {
            return pos.x >= 0 && pos.x < gameManager.gridSize && 
                   pos.y >= 0 && pos.y < gameManager.gridSize;
        }

        public Vector3 GridToWorldPosition(Vector2Int gridPos)
        {
            if (gridSystem != null)
            {
                return gridSystem.GridToWorldPosition(gridPos);
            }
            else
            {
                // Fallback calculation
                float spacing = gameManager.tileSize + gameManager.tileGap;
                return new Vector3(gridPos.x * spacing, gridPos.y * spacing, 0);
            }
        }

        public Vector2Int WorldToGridPosition(Vector3 worldPos)
        {
            if (gridSystem != null)
            {
                return gridSystem.WorldToGridPosition(worldPos);
            }
            else
            {
                // Fallback calculation
                float spacing = gameManager.tileSize + gameManager.tileGap;
                int x = Mathf.RoundToInt(worldPos.x / spacing);
                int y = Mathf.RoundToInt(worldPos.y / spacing);
                return new Vector2Int(Mathf.Clamp(x, 0, gameManager.gridSize - 1), Mathf.Clamp(y, 0, gameManager.gridSize - 1));
            }
        }

        #region Public API
        public WallChessGameManager GetGameManager() => gameManager;
        public GridSystem GetGridSystem() => gridSystem;
        public Camera GetMainCamera() => mainCamera;
        #endregion
    }
}