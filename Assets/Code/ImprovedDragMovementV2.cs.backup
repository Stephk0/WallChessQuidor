using UnityEngine;

namespace WallChess
{
    public class ImprovedDragMovementV2 : MonoBehaviour
    {
        private Camera mainCamera;
        private bool isDragging = false;
        private Vector3 originalPosition;
        private WallChessGameManager gameManager;
        private GridSystem gridSystem;
        private GameObject[] moveHighlights;
        
        [Header("Camera Settings")]
        [SerializeField] private float gamePlaneZ = 0f; // Z position of the game plane
        [SerializeField] private LayerMask raycastLayerMask = -1; // For optional ground plane GameObject

        void Start()
        {
            mainCamera = Camera.main;
            originalPosition = transform.position;
            
            // Find the game manager
            gameManager = FindObjectOfType<WallChessGameManager>();
            if (gameManager != null)
            {
                gridSystem = gameManager.GetGridSystem();
            }
            else
            {
                Debug.LogError("WallChessGameManager not found!");
            }
        }

        void OnMouseDown()
        {
            // Only respond if this is the Player object and it's player's turn
            if (gameObject.name == "Player" && gameManager != null && gameManager.IsPlayerTurn())
            {
                isDragging = true;
                originalPosition = transform.position;
                ShowValidMoveHighlights();
                Debug.Log("Started dragging player");
            }
            else
            {
                Debug.Log($"Cannot move: not player turn or wrong object. State: {(gameManager?.currentState.ToString() ?? "null")}");
            }
        }

        void OnMouseDrag()
        {
            if (isDragging && gameManager != null && gameManager.IsPlayerTurn())
            {
                Vector3 mouseWorldPos = GetMouseWorldPosition();
                transform.position = mouseWorldPos;
            }
        }

        void OnMouseUp()
        {
            if (isDragging)
            {
                ClearHighlights();
                
                Vector3 mouseWorldPos = GetMouseWorldPosition();
                Vector2Int targetGridPos = WorldToGridPosition(mouseWorldPos);
                Vector2Int currentGridPos = WorldToGridPosition(originalPosition);
                
                if (IsValidMove(currentGridPos, targetGridPos))
                {
                    Vector3 snapPosition = GridToWorldPosition(targetGridPos);
                    transform.position = snapPosition;
                    
                    // Update the game manager with the new position
                    if (gameManager != null)
                    {
                        gameManager.MovePlayer(targetGridPos);
                        gameManager.EndTurn(); // End the turn after successful move
                    }
                    
                    Debug.Log($"Player moved to: {targetGridPos}");
                }
                else
                {
                    transform.position = originalPosition;
                    Debug.Log("Invalid move - blocked or out of range");
                }
                
                isDragging = false;
            }
        }

        void ShowValidMoveHighlights()
        {
            Vector2Int currentGrid = WorldToGridPosition(originalPosition);
            Vector2Int[] directions = { 
                Vector2Int.up, Vector2Int.down, 
                Vector2Int.left, Vector2Int.right 
            };

            moveHighlights = new GameObject[4];
            int validMoves = 0;

            for (int i = 0; i < directions.Length; i++)
            {
                Vector2Int targetPos = currentGrid + directions[i];
                
                if (IsValidMove(currentGrid, targetPos))
                {
                    Vector3 worldPos = GridToWorldPosition(targetPos);
                    
                    GameObject highlight = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                    highlight.name = "MoveHighlight";
                    highlight.transform.position = worldPos + Vector3.back * 0.2f;
                    highlight.transform.localScale = Vector3.one * 0.3f;
                    
                    Renderer renderer = highlight.GetComponent<Renderer>();
                    Material mat = new Material(Shader.Find("Universal Render Pipeline/Lit"));
                    mat.color = new Color(0, 1, 0, 0.7f);
                    mat.SetFloat("_Surface", 1); // Transparent
                    mat.SetFloat("_Mode", 3);
                    renderer.material = mat;
                    
                    // Remove collider to prevent interference
                    Collider col = highlight.GetComponent<Collider>();
                    if (col != null) DestroyImmediate(col);
                    
                    moveHighlights[validMoves] = highlight;
                    validMoves++;
                }
            }
        }

        void ClearHighlights()
        {
            if (moveHighlights != null)
            {
                foreach (GameObject highlight in moveHighlights)
                {
                    if (highlight != null)
                        DestroyImmediate(highlight);
                }
                moveHighlights = null;
            }
        }

        /// <summary>
        /// Improved mouse world position calculation using raycasting.
        /// Works consistently with both orthographic and perspective cameras.
        /// </summary>
        Vector3 GetMouseWorldPosition()
        {
            Vector3 mouseScreenPos = Input.mousePosition;
            Ray cameraRay = mainCamera.ScreenPointToRay(mouseScreenPos);
            
            // Method 1: Try raycasting against colliders first (if you have a ground plane GameObject)
            RaycastHit hit;
            if (Physics.Raycast(cameraRay, out hit, Mathf.Infinity, raycastLayerMask))
            {
                return hit.point;
            }
            
            // Method 2: Mathematical plane intersection as fallback
            return RaycastToGamePlane(cameraRay, gamePlaneZ);
        }
        
        /// <summary>
        /// Calculates intersection of camera ray with a plane at specified Z position.
        /// This works for both orthographic and perspective cameras.
        /// </summary>
        private Vector3 RaycastToGamePlane(Ray ray, float planeZ)
        {
            // Create a plane at the specified Z position, facing towards the camera
            Plane gamePlane = new Plane(Vector3.back, new Vector3(0, 0, planeZ));
            
            // Calculate intersection distance
            float intersectionDistance;
            if (gamePlane.Raycast(ray, out intersectionDistance))
            {
                return ray.GetPoint(intersectionDistance);
            }
            
            // Fallback: Project ray to the Z plane mathematically
            // This handles edge cases where Plane.Raycast might fail
            if (Mathf.Abs(ray.direction.z) > 0.001f) // Avoid division by zero
            {
                float t = (planeZ - ray.origin.z) / ray.direction.z;
                return ray.origin + ray.direction * t;
            }
            
            // Final fallback: return ray origin projected to game plane
            return new Vector3(ray.origin.x, ray.origin.y, planeZ);
        }

        Vector2Int WorldToGridPosition(Vector3 worldPos)
        {
            if (gridSystem != null)
            {
                return gridSystem.WorldToGridPosition(worldPos);
            }
            else
            {
                // Fallback calculation
                float gridSpacing = 1.2f;
                int x = Mathf.RoundToInt(worldPos.x / gridSpacing);
                int y = Mathf.RoundToInt(worldPos.y / gridSpacing);
                return new Vector2Int(Mathf.Clamp(x, 0, 8), Mathf.Clamp(y, 0, 8));
            }
        }

        Vector3 GridToWorldPosition(Vector2Int gridPos)
        {
            if (gridSystem != null)
            {
                return gridSystem.GridToWorldPosition(gridPos);
            }
            else
            {
                // Fallback calculation
                float gridSpacing = 1.2f;
                return new Vector3(gridPos.x * gridSpacing, gridPos.y * gridSpacing, gamePlaneZ);
            }
        }

        bool IsValidMove(Vector2Int from, Vector2Int to)
        {
            // Check bounds
            if (to.x < 0 || to.x > 8 || to.y < 0 || to.y > 8)
                return false;

            // Check if it's adjacent move
            int deltaX = Mathf.Abs(to.x - from.x);
            int deltaY = Mathf.Abs(to.y - from.y);
            
            if (!((deltaX == 1 && deltaY == 0) || (deltaX == 0 && deltaY == 1)))
                return false;
            
            // Check if target tile is occupied
            if (gridSystem != null && gridSystem.IsTileOccupied(to))
                return false;
            
            // Check wall collisions
            if (gridSystem != null)
            {
                return !gridSystem.IsMovementBlocked(from, to);
            }
            else
            {
                // Fallback to old collision checker
                Vector3 fromWorld = GridToWorldPosition(from);
                Vector3 toWorld = GridToWorldPosition(to);
                return !ImprovedCollisionChecker.IsBlocked(fromWorld, toWorld);
            }
        }
        
        // Additional debug method to test mouse input
        void Update()
        {
            // Debug mouse clicks
            if (Input.GetMouseButtonDown(0))
            {
                Vector3 mouseWorldPos = GetMouseWorldPosition();
                Vector2Int gridPos = WorldToGridPosition(mouseWorldPos);
                Debug.Log($"Mouse clicked at world: {mouseWorldPos}, grid: {gridPos}");
                
                // Check if we can detect the player object
                Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);
                RaycastHit hit;
                if (Physics.Raycast(ray, out hit))
                {
                    Debug.Log($"Raycast hit: {hit.collider.gameObject.name}");
                }
            }
        }
    }
}